/**
 * Context Loader
 *
 * Loads pre-computed repository context from .claude/context/ directory.
 * Context is generated by Opus via /generate-qwen-context skill and
 * optimized for Qwen 2.5 Coder's processing capabilities.
 */

import { readFile } from 'fs/promises';
import { join } from 'path';
import { existsSync } from 'fs';

/**
 * Structured pattern for matching against changed files.
 */
export interface Pattern {
  id: string;
  type: 'architecture' | 'convention' | 'anti-pattern' | 'security';
  description: string;
  files: string[]; // Glob patterns
  antiPattern?: string; // Regex for detecting violations
  weight: number; // 0-1 relevance score
}

/**
 * Qwen-optimized prompt fragments for each agent type.
 */
export interface QwenPromptFragments {
  securityPreamble: string;
  breakingPreamble: string;
  testCoveragePreamble: string;
  performancePreamble: string;
  codebaseQualityPreamble: string;
}

/**
 * Complete base context loaded from .claude/context/ files.
 */
export interface BaseContext {
  /** Human-readable repo patterns from base.md */
  repoPatterns: string;
  /** Structured patterns from patterns.json */
  structuredPatterns: Pattern[];
  /** Prompt fragments from qwen-prompts.md */
  qwenPrompts: QwenPromptFragments;
  /** Whether context was loaded from files or is using defaults */
  hasCustomContext: boolean;
}

const DEFAULT_CONTEXT: BaseContext = {
  repoPatterns: '',
  structuredPatterns: [],
  qwenPrompts: {
    securityPreamble: '',
    breakingPreamble: '',
    testCoveragePreamble: '',
    performancePreamble: '',
    codebaseQualityPreamble: '',
  },
  hasCustomContext: false,
};

/**
 * Parse qwen-prompts.md into structured fragments.
 */
function parseQwenPrompts(content: string): QwenPromptFragments {
  const fragments: QwenPromptFragments = {
    securityPreamble: '',
    breakingPreamble: '',
    testCoveragePreamble: '',
    performancePreamble: '',
    codebaseQualityPreamble: '',
  };

  // Extract sections by headers
  const sections = content.split(/^## /m).filter(Boolean);

  for (const section of sections) {
    const lines = section.trim().split('\n');
    const header = lines[0].toLowerCase();
    const body = lines.slice(1).join('\n').trim();

    if (header.includes('security')) {
      fragments.securityPreamble = body;
    } else if (header.includes('breaking')) {
      fragments.breakingPreamble = body;
    } else if (header.includes('test')) {
      fragments.testCoveragePreamble = body;
    } else if (header.includes('performance')) {
      fragments.performancePreamble = body;
    } else if (header.includes('codebase') || header.includes('quality')) {
      fragments.codebaseQualityPreamble = body;
    }
  }

  return fragments;
}

/**
 * Load base context from .claude/context/ directory.
 *
 * @param repoRoot - Root directory of the repository
 * @returns BaseContext with loaded or default values
 */
export async function loadBaseContext(repoRoot: string): Promise<BaseContext> {
  const contextDir = join(repoRoot, '.claude', 'context');

  // Check if context directory exists
  if (!existsSync(contextDir)) {
    console.log('â„¹ï¸  No .claude/context/ found, using default context');
    return DEFAULT_CONTEXT;
  }

  const context: BaseContext = {
    repoPatterns: '',
    structuredPatterns: [],
    qwenPrompts: {
      securityPreamble: '',
      breakingPreamble: '',
      testCoveragePreamble: '',
      performancePreamble: '',
      codebaseQualityPreamble: '',
    },
    hasCustomContext: true,
  };

  // Load base.md (repo patterns)
  const baseMdPath = join(contextDir, 'base.md');
  if (existsSync(baseMdPath)) {
    try {
      context.repoPatterns = await readFile(baseMdPath, 'utf-8');
    } catch (e) {
      console.warn('âš ï¸  Failed to load base.md:', e);
    }
  }

  // Load patterns.json (structured patterns)
  const patternsJsonPath = join(contextDir, 'patterns.json');
  if (existsSync(patternsJsonPath)) {
    try {
      const content = await readFile(patternsJsonPath, 'utf-8');
      const parsed = JSON.parse(content);
      if (Array.isArray(parsed.patterns)) {
        context.structuredPatterns = parsed.patterns;
      }
    } catch (e) {
      console.warn('âš ï¸  Failed to load patterns.json:', e);
    }
  }

  // Load qwen-prompts.md (prompt fragments)
  const qwenPromptsPath = join(contextDir, 'qwen-prompts.md');
  if (existsSync(qwenPromptsPath)) {
    try {
      const content = await readFile(qwenPromptsPath, 'utf-8');
      context.qwenPrompts = parseQwenPrompts(content);
    } catch (e) {
      console.warn('âš ï¸  Failed to load qwen-prompts.md:', e);
    }
  }

  console.log(`ðŸ“‚ Loaded context from ${contextDir}`);
  console.log(`   Patterns: ${context.structuredPatterns.length}`);
  console.log(`   Has repo patterns: ${context.repoPatterns.length > 0}`);

  return context;
}

/**
 * Get patterns matching a specific type.
 */
export function getPatternsByType(
  patterns: Pattern[],
  type: Pattern['type']
): Pattern[] {
  return patterns.filter((p) => p.type === type);
}

/**
 * Get high-weight patterns (weight >= threshold).
 */
export function getHighWeightPatterns(
  patterns: Pattern[],
  threshold: number = 0.8
): Pattern[] {
  return patterns.filter((p) => p.weight >= threshold);
}
